[
["index.html", "MARSS wiki 1 ReadMe 1.1 Contribute 1.2 Downloading the Rmds", " MARSS wiki 1 ReadMe 1.1 Contribute Write an Rmd file. Go to rmdfiles folder Click on Upload files Select ‘Create new branch and start a pull request’ Each Rmd file contains one and only one entry/vignette. The title of your vignette must be at the top of your Rmd and have # (chapter level). Subsequent headings should be ##. Don’t add yaml to the top of your Rmd. Look at an existing Rmd in the folder for an example. You can write math in normal LaTeX, but you need to escape the equation ref (so looks like \\\\ref{}). You can also post at the wiki associated with the MARSS repo, but then it’ll just be raw R or Rmd code. MARSS simple wiki 1.2 Downloading the Rmds Move mouse up to header of the example you want to download. Click on the “pencil” icon to take you to GitHub. In the top right, RIGHT click on Raw button. Save as … "],
["math-and-eqn-numbering.html", "2 Math and Eqn numbering", " 2 Math and Eqn numbering In the pdf, this will not have a number but in the html it will. \\[ \\AA^\\top\\BB \\] You can use nonumber if you need the equation numbering to be the same in html and pdf. \\[ \\AA^\\top\\BB\\nonumber \\] If we want to crossref an equation, use equation environment and escape the ref command so it looks like \\\\ref{}. This is Equation \\ref{eqn1}. \\[\\begin{equation} \\AA^\\top\\BB \\label{eqn1}\\end{equation}\\] This is Equation \\ref{eqn1}. "],
["plot-states-from-a-marss-fit.html", "3 Plot states from a MARSS fit", " 3 Plot states from a MARSS fit date: March 16, 2018 Required packages library(MARSS) library(broom) library(ggplot2) library(dplyr) if(packageVersion(&quot;MARSS&quot;)&lt;&quot;3.10.4&quot;) stop(&quot;Need MARSS version 3.10.4 at least.&quot;, call.=FALSE) Fit a model data(harborSealWA) kemfit &lt;- MARSS(t(harborSealWA[,-1]), model=list(Z=as.factor(c(1,1,1,1,2)), R=&quot;diagonal and equal&quot;)) Create a function for fitting. plot_fitted = function(fitted_model, type=c(&quot;states&quot;, &quot;fits&quot;)) { if(type==&quot;states&quot;) { states = tidy(kemfit, &quot;states&quot;) states = dplyr::rename(states, state=term) states$state = paste0(&quot;State &quot;,states$state) g = ggplot(states, aes(t, estimate)) + geom_ribbon(aes(ymin = conf.low, ymax=conf.high), alpha=0.3, col=&quot;grey&quot;) + geom_line() + xlab(&quot;Time&quot;) + ylab(&quot;Estimate&quot;) + facet_wrap(~state, scale=&quot;free_y&quot;) return(g) } } plot = plot_fitted(kemfit, type=&quot;states&quot;) print(plot) We can still manipulate / add to the plot of the states as we would with any other ggplot() graphics. for example, add a title: plot = plot + ggtitle(&quot;2 - trend MARSS model&quot;) print(plot) "],
["plot-states-from-a-dfa-using-ggplot.html", "4 Plot states from a DFA using ggplot", " 4 Plot states from a DFA using ggplot date: March 15, 2018 Requires MARSS 3.10.5+ Required packages library(MARSS) library(broom) library(ggplot2) if(packageVersion(&quot;MARSS&quot;)&lt;&quot;3.10.4&quot;) stop(&quot;Need MARSS version 3.10.4 at least.&quot;) Load data and zscore data(lakeWAplankton) # we want lakeWAplanktonTrans, which has been log-transformed # and the 0s replaced with NAs plankdat = lakeWAplanktonTrans years = plankdat[,&quot;Year&quot;]&gt;=1980 &amp; plankdat[,&quot;Year&quot;]&lt;1990 phytos = c(&quot;Cryptomonas&quot;, &quot;Diatoms&quot;, &quot;Greens&quot;, &quot;Unicells&quot;, &quot;Other.algae&quot;) dat.spp.1980 = plankdat[years,phytos] # transpose data so time goes across columns dat.spp.1980 = t(dat.spp.1980) dat.z = zscore(dat.spp.1980) Fit a DFA with 3 trends. Setting maxit to 50, so it runs fast. model.list = list(m=3, R=&quot;diagonal and unequal&quot;) kemz.3 = MARSS(dat.spp.1980, model=model.list, z.score=TRUE, form=&quot;dfa&quot;, control=list(maxit=50)) Make a plot of trends with CIs theme_set(theme_bw()) d &lt;- tidy(kemz.3, type=&quot;states&quot;) ggplot(data = d) + geom_line(aes(t, estimate)) + geom_ribbon(aes(x=t, ymin=conf.low, ymax=conf.high), linetype=2, alpha=0.1) + facet_grid(~term) + xlab(&quot;Time Step&quot;) + ylab(&quot;Val&quot;) require(MARSS) "],
["time-varying-population-growth-rates-univariate.html", "5 Time-varying population growth rates: univariate 5.1 Univariate model", " 5 Time-varying population growth rates: univariate In this case study, we will use MARSS to fit a time-varying MAR model, that is a MAR model in which the parameters are time-varying. In the economics literature, such models are known as time-varying VAR models (TVAR). In this example, we use a time-varying MAR to model a stage-structured population with stage-specific survivals and fecundity that vary with time according to an auto-regressive process. We assume for this case study that the data do not have observation error; that is, that the observations are the true population size. The models in this chapter are a form of dynamic linear model (DLM), and the reader may want to review the chapter on DLMs in the User Guide. 5.1 Univariate model Before doing the multivariate case (time-varying MAR), we show a univariate case or the time-varying AR model using a simple population model with exponential growth. This model is typically written as follows: \\[\\begin{equation} n_t = n_{t-1}(\\lambda \\times exp(w_t)) \\label{tmar:se}\\end{equation}\\] where \\(w_t\\) are normal errors and \\(\\lambda\\) is the population growth rate. This is the vanilla stochastic exponential growth model and the lognormal errors (\\(exp(w_t)\\)) mean that \\(\\lambda\\) make proportional changes (e.g. +/- 10% rather than +/- 0.1) and stays positive. Written in log-space, this is \\(\\log(n_t) = \\log(n_{t-1}) + \\log(\\lambda) + w_t\\) where \\(w_t \\sim \\N(0, \\sigma^2)\\). When we work with this model in log-space, we have a linear model with Gaussian errors. This is one reason we would normally log transform the data. However, we are working up to a multivariate version of this model, where we cannot convert to a linear model by a log transformation. Thus, we are not going to log-transform the data here. If we do not log transform our data (the \\(n\\)), we could approximate Equation \\ref{tmar:se} with the following model: \\[\\begin{equation} \\begin{gathered} n_t = n_{t-1} \\lambda_t \\\\ \\lambda_t = \\bar{\\lambda} + w_t \\end{gathered} \\label{tmar:se2} \\end{equation}\\] where \\(w_t\\) is \\(\\N(0, \\approx \\sigma^2)\\) if \\(\\sigma\\) is small. This is a terrible approximation if \\(\\sigma\\) is big but for many population models, survival and fecundity are varying no more than +/- 50% per year (or other relevant time step). In this case, approximating \\(\\bar{\\lambda} \\times exp(w_t))\\) with a normal distribution is not too terrible. The point of rewriting the stochastic exponential in this way is that we now can model \\(\\lambda_t\\) in other ways. \\(\\lambda_t=\\bar{\\lambda} + w_t\\) means that the mean population growth rate in year \\(t\\) (\\(\\lambda_t\\)) just fluctuates around \\(\\bar{\\lambda}\\) with no temporal correlation or trend up or down. We could model long-term (and potentially large) changes in the population growth rate by modeling \\(\\lambda_t\\) as a random walk, similar to the approach taken in dynamic linear modeling. \\[\\begin{equation} \\begin{gathered} \\lambda_t = \\lambda_{t-1} + w_t, w_t \\sim \\N(0,q) \\end{gathered} \\label{tmar:unirw1} \\end{equation}\\] Or we might model the \\(\\bar{\\lambda}\\) as a random walk and allow the \\(\\lambda_t\\) to be a function of that. This is white noise with a random walk mean: \\[\\begin{equation} \\begin{gathered} \\bar{\\lambda}_t = \\bar{\\lambda}_{t-1} + w_{1,t}, w_{1,t} \\sim \\N(0,q_1)\\\\ \\lambda_t = \\bar{\\lambda}_t + w_{2,t}, w_{2,t} \\sim \\N(0,q_2) \\end{gathered} \\label{tmar:unirw2} \\end{equation}\\] We could also model \\(\\lambda_t\\) as having a long-term trend (drift) upward or downward but allow it to wander at the same time. We can do this by adding a drift term \\(u\\) to the \\(\\lambda_t\\) random walk model. \\[\\begin{equation} \\begin{gathered} \\lambda_t = \\lambda_{t-1} + u + w_t, w_t \\sim \\N(0,q)\\\\ \\lambda_0 = \\bar{\\lambda} \\end{gathered} \\label{tmar:unirwwd}\\end{equation}\\] We could model \\(\\lambda_t\\) as having a mean value but allow it to drift around that with correlation. We can do this using a mean-reverting random walk model: \\[\\begin{equation} \\begin{gathered} \\lambda_t = b \\lambda_{t-1} + u + w_t, w_t \\sim \\N(0,q)\\\\ \\bar{\\lambda} = u/(1-b) \\end{gathered} \\label{tmar:unimrw}\\end{equation}\\] We could model \\(\\lambda_t\\) as having a mean value but year-to-year correlation by using a moving average of idependent errors. This is a common approach for introducing correlation into the errors in a time-series model. \\[\\begin{equation} \\begin{gathered} \\lambda_t = \\bar{\\lambda}+\\begin{bmatrix}1&amp;\\theta\\end{bmatrix}\\begin{bmatrix}w_t&amp;w_{t-1}\\end{bmatrix}\\\\ w_t \\sim N(0,q) \\end{gathered} \\label{tmar:sema}\\end{equation}\\] par(mfrow=c(2,2)) TT=100 barl=1.01 drift=.001 b=.90 s=sqrt(.001) a=barl*(1-b) err=c(0,rnorm(TT-1,0,s)) err2=c(0,rnorm(TT-1,0,s)) err3=c(0,rnorm(TT-1,0,s)) #white noise around a mean lambda ylims=c(0,3) plot(barl+err,type=&quot;l&quot;,ylim=ylims,bty=&quot;l&quot;,ylab=&quot;r_t&quot;,xlab=&quot;t&quot;) title(&quot;White Noise&quot;) lines(barl+err2,col=&quot;red&quot;) lines(barl+err3,col=&quot;blue&quot;) #random walk plot(barl+cumsum(err),type=&quot;l&quot;,ylim=ylims,bty=&quot;l&quot;,ylab=&quot;r_t&quot;,xlab=&quot;t&quot;) title(&quot;Random Walk&quot;) lines(barl+cumsum(err2),col=&quot;red&quot;) lines(barl+cumsum(err3),col=&quot;blue&quot;) #white noise around a random walk mean lambda #plot(barl+cumsum(err)+err2,type=&quot;l&quot;,ylim=ylims,bty=&quot;l&quot;,ylab=&quot;r_t&quot;,xlab=&quot;t&quot;) #title(&quot;Random Walking Mean&quot;) #lines(barl+cumsum(err2)+err3,col=&quot;red&quot;) #lines(barl+cumsum(err3)+err,col=&quot;blue&quot;) #random walk with drift plot(barl+cumsum(err+drift),type=&quot;l&quot;,ylim=ylims,bty=&quot;l&quot;,ylab=&quot;r_t&quot;,xlab=&quot;t&quot;) title(&quot;Random Walk with Drift&quot;) lines(barl+cumsum(err2+drift),col=&quot;red&quot;) lines(barl+cumsum(err3+drift),col=&quot;blue&quot;) #mean reverting random walk n=barl for(i in 2:TT) n[i]=a+b*n[i-1]+err[i] plot(n,type=&quot;l&quot;,ylim=ylims,bty=&quot;l&quot;,ylab=&quot;r_t&quot;,xlab=&quot;t&quot;) title(&quot;Mean-Reverting Random Walk&quot;) for(i in 2:TT) n[i]=a+b*n[i-1]+err2[i] lines(n,type=&quot;l&quot;,ylim=ylims,col=&quot;red&quot;) for(i in 2:TT) n[i]=a+b*n[i-1]+err3[i] lines(n,type=&quot;l&quot;,ylim=ylims,col=&quot;blue&quot;) (#fig:Cs01-tmar.rt)Examples of \\(\\lambda_t\\) trajectories for the four different \\(\\lambda_t\\) models. Each color of line uses the same input errors: randomly drawn from a Normal distribution with mean of 0 and standard deviation of 0.1. The drift term is 0.01. Mean-reversion (\\(b\\)) is 0.9. \\(ar(\\lambda)\\) is 1.1. Let’s create some simulated data with mean population growth rate set at 1.01 (so an increasing population). set.seed(13) #and interesting case TT=100 barl=1.01 drift=.001 #drift n0 = 100 s=sqrt(.001) err=c(0,rnorm(TT,0,s)) #process errors #white noise n.wn = n0 lambdat=barl+err for(i in 2:TT) n.wn[i] = n.wn[i-1]*lambdat[i] #random walk n.rw = n0 lambdat=barl+cumsum(err) for(i in 2:TT) n.rw[i] = n.rw[i-1]*lambdat[i] #random walk with drift n.rwd = n0 lambdat=barl+cumsum(err+drift) for(i in 2:TT) n.rwd[i] = n.rwd[i-1]*lambdat[i] #mean-reverting random walk b=.90 u=barl*(1-b) lambdat=barl n.mrw = n0 for(i in 2:TT){ lambdat[i]=u+b*lambdat[i-1]+err[i] n.mrw[i] = n.mrw[i-1]*lambdat[i] } matplot(log(cbind(n.wn,n.rw,n.rwd,n.mrw)),type=&quot;l&quot;,ylab=&quot;t&quot;,xlab=&quot;N&quot;,col=c(&quot;black&quot;,&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;)) legend(&quot;topright&quot;, c(&quot;white noise&quot;, &quot;random walk&quot;, &quot;rw with drift&quot;,&quot;mean-reverting rw&quot;), col=c(&quot;black&quot;,&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;), bty=&quot;l&quot;, lty=1) Figure 5.1: Simulated population counts with different \\(\\lambda_t\\) models. Let’s fit these data using statistical model written in MARSS form. To do this, we need to write our model in matrix form: \\[\\begin{equation} \\begin{gathered} \\yy_t = \\ZZ_t \\xx_t + \\aa_t + \\vv_t, \\vv_t \\sim \\MVN(0,\\RR)\\\\ \\xx_t = \\BB_t \\xx_{t-1} + \\uu_t + \\ww_t, \\ww_t \\sim \\MVN(0,\\QQ) \\end{gathered}\\label{eqn:tmarss.uni} \\end{equation}\\] Before we do this translation, let’s think about what the \\(n_t\\) are relative to our data which are observations not actually the true population size. We can treat our observations as error-free observations of \\(n_t\\), so \\(o_t=n_t\\), or we might think there is some error in our observations, so \\(o_t=n_t+e_t\\). Let’s start with treating our observations as perfect so \\(o_t=n_t\\). Our model takes the form \\[\\begin{equation} \\begin{gathered} o_t = o_{t-1} s_t\\\\ \\lambda_t = b \\lambda_{t-1} + u + w_t, w_t \\sim \\N(0, q) \\end{gathered}\\label{eqn:rw.no.err} \\end{equation}\\] Notice that all the process error is coming from \\(\\lambda_t\\), which is fluctuating year to year. Comparing Equation \\ref{eqn:rw.no.err} to \\ref{eqn:tmarss.uni}, we see that \\(\\ZZ_t \\equiv o_{t-1}\\), \\(\\xx_t \\equiv s_t\\), \\(\\BB \\equiv b\\), and the other parameters, \\(u\\), \\(c\\) and \\(q\\), have the same names. Remember that even though we are starting with a univariate case, the MARSS() function needs all parameters specified as matrices. Even scalars need to be specified as \\(1 \\times 1\\) matrices. Now we can set this up in R. Let’s start with the model where \\(\\lambda_t\\) is white noise, so simply fluctuating randomly about some mean temporally-constant population growth rate. Our \\(\\lambda_t\\) model reduces to \\[\\begin{equation} \\begin{gathered} o_t = o_{t-1} \\lambda_t\\\\ \\lambda_t = \\bar{\\lambda} + w_t, w_t \\sim \\N(0, q) \\end{gathered}\\label{eqn:rw.no.err} \\end{equation}\\] Notice that \\(\\lambda_0\\) does not appear in this model because \\(t\\) starts at 1 (because the data start at \\(t=1\\)). In R, this model is #lambda_t is wn dat = n.wn #Z is n at t-1 starting at t=1 up to t=TT-1 Z=array(dat[1:(TT-1)],dim=c(1,1,TT-1)) #no observation error and no a in the y equation R = &quot;zero&quot;; A=&quot;zero&quot; #state eqn. Specify B, W, and U #white noise #x_t = U + w_t #Q is univariate so diagonal and equal or unequal would be the same B=&quot;zero&quot;; Q=&quot;unconstrained&quot; U=matrix(&quot;mean.lambda&quot;) #specify the initial states #because x0 does not appear in the model we can fix it at 0 x0=matrix(0) V0=&quot;zero&quot; Now we can fit the model. Notice that the first time-step of the data was used in \\(\\ZZ\\), therefore we need to strip that first time step off the data we pass to the MARSS() function. #univariate white noise model for lambda_t model.uwn=list(Z=Z, R=R, A=A, B=B, Q=Q, U=U, x0=x0, V0=V0) tmp=MARSS(dat[2:TT], model=model.uwn) ## Success! abstol and log-log tests passed at 16 iterations. ## Alert: conv.test.slope.tol is 0.5. ## Test with smaller values (&lt;0.1) to ensure convergence. ## ## MARSS fit is ## Estimation method: kem ## Convergence test: conv.test.slope.tol = 0.5, abstol = 0.001 ## Estimation converged in 16 iterations. ## Log-likelihood: -294.8938 ## AIC: 593.7875 AICc: 593.9125 ## ## Estimate ## U.mean.lambda 1.007752 ## Q.Q 0.000895 ## Initial states (x0) defined at t=0 ## ## Standard errors have not been calculated. ## Use MARSSparamCIs to compute CIs and bias estimates. "]
]
